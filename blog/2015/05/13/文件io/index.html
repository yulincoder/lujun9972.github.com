<!DOCTYPE html>
<html lang="en">
<head>
  <title>文件IO - 浩劫残阳</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="author" content="DarkSun" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #ds-thread #ds-reset .ds-comment-body p a {color: #ff0;}
   #ds-thread #ds-reset .ds-comment-body p a:hover {color: #0ff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" href="http://lujun9972.github.io/media/css/main.css" type="text/css">
  <link rel="stylesheet" href="http://lujun9972.github.io/media/css/comment.css" type="text/css">
  <script type="text/javascript"
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG">
  </script>
  <script type="text/x-mathjax-config">
          MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
  </script>
</head>

  <body><div class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="http://lujun9972.github.io/">浩劫残阳</a></h1>
    <p>=============&gt;随便写写</p>
    <nav class="site-nav">
      <div class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z" fill="#ffff00"/>
          <path d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z" fill="#ffff00"/>
          <path d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z" fill="#ffff00"/>
        </svg>
      </div>
      <ul class="trigger">
        <li><a href="http://lujun9972.github.io/years/">Years</a></li>
        <li><a href="http://lujun9972.github.io/authors/">Authors</a></li>
        <li><a href="http://lujun9972.github.io/tags/">Tags</a></li>
        <li><a href="http://lujun9972.github.io/about/">About</a></li>
        <li><a href="https://github.com/lujun9972">Github</a></li>
        <li><a href="http://lujun9972.github.io/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="lujun9972.github.io">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">文件IO</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 基本文件IO操作函数</a>
<ul>
<li><a href="#sec-1-1">1.1. open函数</a></li>
<li><a href="#sec-1-2">1.2. create函数</a></li>
<li><a href="#sec-1-3">1.3. close函数</a></li>
<li><a href="#sec-1-4">1.4. lseek函数</a></li>
<li><a href="#sec-1-5">1.5. read函数</a></li>
<li><a href="#sec-1-6">1.6. write函数</a></li>
</ul>
</li>
<li><a href="#sec-2">2. 文件共享</a>
<ul>
<li><a href="#sec-2-1">2.1. 内核是如何表示打开的文件的?</a></li>
<li><a href="#sec-2-2">2.2. 当多个进程打开同一个文件时,发生了什么?</a></li>
<li><a href="#sec-2-3">2.3. 多个进程打开同一个文件带来的影响是什么?</a></li>
<li><a href="#sec-2-4">2.4. dup和dup2函数</a></li>
</ul>
</li>
<li><a href="#sec-3">3. sync,fsync和fdatasync</a></li>
<li><a href="#sec-4">4. fcntl函数</a></li>
<li><a href="#sec-5">5. ioctl函数</a></li>
<li><a href="#sec-6">6. /dev/fd</a>
<ul>
<li><a href="#sec-6-1">6.1. 参数filedes</a></li>
<li><a href="#sec-6-2">6.2. 参数cmd</a></li>
</ul>
</li>
<li><a href="#sec-7">7. 非阻塞IO</a>
<ul>
<li><a href="#sec-7-1">7.1. 指定非阻塞IO的方法</a></li>
</ul>
</li>
<li><a href="#sec-8">8. 记录锁</a>
<ul>
<li><a href="#sec-8-1">8.1. fcntl记录锁</a>
<ul>
<li><a href="#sec-8-1-1">8.1.1. cmd操作说明</a></li>
<li><a href="#sec-8-1-2">8.1.2. flock结构说明</a></li>
</ul>
</li>
<li><a href="#sec-8-2">8.2. 关于锁的释放与继承</a>
<ul>
<li><a href="#sec-8-2-1">8.2.1. 锁的释放</a></li>
<li><a href="#sec-8-2-2">8.2.2. 锁的继承</a></li>
</ul>
</li>
<li><a href="#sec-8-3">8.3. 建议性锁和强制性锁</a></li>
<li><a href="#sec-8-4">8.4. flock文件锁</a></li>
</ul>
</li>
<li><a href="#sec-9">9. IO多路转换</a>
<ul>
<li><a href="#sec-9-1">9.1. select</a>
<ul>
<li><a href="#sec-9-1-1">9.1.1. 时间参数tvptr意义说明:</a></li>
<li><a href="#sec-9-1-2">9.1.2. fd_set数据类型说明</a></li>
<li><a href="#sec-9-1-3">9.1.3. fd_set*三个参数说明</a></li>
<li><a href="#sec-9-1-4">9.1.4. 参数maxfdp说明</a></li>
</ul>
</li>
<li><a href="#sec-9-2">9.2. pselect</a>
<ul>
<li><a href="#sec-9-2-1">9.2.1. pselect与select的不同之处</a></li>
</ul>
</li>
<li><a href="#sec-9-3">9.3. 函数poll</a>
<ul>
<li><a href="#sec-9-3-1">9.3.1. poll中的事件说明</a></li>
<li><a href="#sec-9-3-2">9.3.2. timeout说明</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-10">10. POSIX异步IO</a>
<ul>
<li><a href="#sec-10-1">10.1. 异步读写操作</a></li>
<li><a href="#sec-10-2">10.2. 强制同步</a></li>
<li><a href="#sec-10-3">10.3. 获取异步读,写,同步操作的完成状态</a></li>
<li><a href="#sec-10-4">10.4. 异步操作管理</a></li>
</ul>
</li>
<li><a href="#sec-11">11. 散布读(scatter read)和聚集写(gather write)</a></li>
<li><a href="#sec-12">12. 存储映射IO</a>
<ul>
<li><a href="#sec-12-1">12.1. 将文件映射到缓冲区</a></li>
<li><a href="#sec-12-2">12.2. 更改映射权限</a></li>
<li><a href="#sec-12-3">12.3. 写回修改到源文件</a>
<ul>
<li><a href="#sec-12-3-1">12.3.1. flags参数说明</a></li>
</ul>
</li>
<li><a href="#sec-12-4">12.4. 解除映射</a></li>
<li><a href="#sec-12-5">12.5. 相关信号</a></li>
<li><a href="#sec-12-6">12.6. 关于子进程的共享问题</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 基本文件IO操作函数</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> open函数</h3>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> create函数</h3>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> close函数</h3>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> lseek函数</h3>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> read函数</h3>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> write函数</h3>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 文件共享</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 内核是如何表示打开的文件的?</h3>
<div class="outline-text-3" id="text-2-1">
<p>
内核使用三种数据结构表示打开的文件,它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响.
</p>
<ul class="org-ul">
<li>每个进程在进程表中都有一个记录项,记录项中包含有一张打开文件描述符的表. 

<p>
每个文件描述符符与一个指向文件表项的指针相关联. 而文件表项保持在内核中
</p>
</li>

<li>内核为所有打开的文件维护一张文件表. 其中每个文件表项包括:

<ul class="org-ul">
<li>文件状态标志(读,写,添写,同步,非阻塞&#x2026;)
</li>

<li>当前文件偏移量
</li>

<li>指向表示该文件的v节点表项的指针
</li>
</ul>
</li>

<li>每个打开的文件(或设备)都有一个v节点结构.

<p>
v节点包含了文件类型和对此文件进行各种操作的函数的指针.
</p>

<p>
对于大多数文件,v节点还包含了该文件的i节点信息.
</p>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 当多个进程打开同一个文件时,发生了什么?</h3>
<div class="outline-text-3" id="text-2-2">
<p>
一般来说,多个进程打开同一个文件时,会分别在不同的文件描述符上打开该文件. 不同的文件描述符指向不同的文件表项. 但不同的文件表项指向了同一个v节点.
</p>

<p>
即,每个文件都有自己独立的文件描述符和文件表项,但共用同一个文件v节点.
</p>

<p>
但当使用dup函数或fork时,也可能出现多个文件描述符项指向同一个文件表项
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 多个进程打开同一个文件带来的影响是什么?</h3>
<div class="outline-text-3" id="text-2-3">
<p>
多个进程读取同一个文件时,由于各个进程都由自己的文件表项,也就有自己的当前文件偏移符,因此多个进程读取同一个文件时很正常.
</p>

<p>
但当多个进程写入同一个文件时,由于各自不同的文件偏移符,所以可能出现写入内容相互覆盖的情况.
</p>

<p>
解决多个进程写入同一个文件的一个方法是,在打开文件时设置O_APPEND标志. 这种情况下,内核每次对该文件进行写之前,都将该进程的当前偏移量设置到文件的尾端.
</p>

<p>
XSI扩展还定义了pread和pwrite函数用于将定位搜索和执行IO统一为一个原子操作:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;unistd.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#20808;lseek&#21040;offset&#22788;,&#28982;&#21518;&#35835;&#21462;&#25991;&#20214;&#20869;&#23481; </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">ssize_t</span> <span style="color: #0000ff;">pread</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">filedes</span>,<span style="color: #228b22;">void</span>* <span style="color: #a0522d;">buf</span>,<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>,<span style="color: #228b22;">off_t</span> <span style="color: #a0522d;">offset</span>);

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#20808;lseek&#21040;offset&#22788;,&#28982;&#21518;&#20889;&#20837;buf&#20869;&#23481; </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">ssize_t</span> <span style="color: #0000ff;">pwrite</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">filedes</span>,<span style="color: #a020f0;">const</span> <span style="color: #228b22;">void</span>* <span style="color: #a0522d;">buf</span>,<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>,<span style="color: #228b22;">off_t</span> <span style="color: #a0522d;">offset</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> dup和dup2函数</h3>
<div class="outline-text-3" id="text-2-4">
<p>
可以用dup和dup2函数来复制一个现存的文件描述符,复制出来的文件描述符与原文件描述符共享同一个文件表项,即它们共享同一个文件标志状态及文件偏移量:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;unistd.h&gt;</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">dup&#36820;&#22238;&#30340;&#26032;&#25991;&#20214;&#25551;&#36848;&#31526;&#26159;&#24403;&#21069;&#21487;&#29992;&#25991;&#20214;&#25551;&#36848;&#31526;&#30340;&#26368;&#23567;&#25968;&#20540;</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">dup</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">filedes</span>);

<span style="color: #b22222;">// </span><span style="color: #b22222;">dup2&#21487;&#20197;&#29992;filedes2&#21442;&#25968;&#25351;&#23450;&#26032;&#25551;&#36848;&#31526;&#30340;&#25968;&#20540;.</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">&#22914;&#26524;filedes2&#24050;&#32463;&#25171;&#24320;,&#21017;&#20808;&#20851;&#38381;&#23427;.</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">&#22914;&#26524;filedes == filedes2,&#21017;dup2&#30452;&#25509;&#36820;&#22238;filedes2,&#32780;&#19981;&#20851;&#38381;&#23427;</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">dup2</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">filedes</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">filedes2</span>);
</pre>
</div>

<p>
除了dup和dup2外,也可以使用fcntl函数来复制描述符.
</p>
<div class="org-src-container">

<pre class="src src-c++">dup(filedes);
<span style="color: #b22222;">// </span><span style="color: #b22222;">&#31867;&#20284;&#20110;</span>
fcntl(filedes,F_DUPFD,0);

dup2(filedes,filedes2);
<span style="color: #b22222;">// </span><span style="color: #b22222;">&#31867;&#20284;&#20110;</span>
close(filedes2);fcntl(filedes,F_DUPFD,filedes2);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> sync,fsync和fdatasync</h2>
<div class="outline-text-2" id="text-3">
<p>
传统UNIX实现在内核中设置了缓冲区,当数据写入文件时,内核现将数据复制到一个缓冲区中,而不立即将其排入输出队列.
</p>

<p>
UNIX系统提供了sync,fsync和fdatasync三个函数用于通知内核将数据立即排入输出队列中:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;unistd.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#23558;filedes&#25351;&#23450;&#30340;&#25991;&#20214;&#20869;&#23481;&#20889;&#20837;&#30913;&#30424;,&#35813;&#20989;&#25968;&#31561;&#24453;&#20889;&#30913;&#30424;&#25805;&#20316;&#32467;&#26463;&#21518;&#25165;&#36820;&#22238;,&#24182;&#21516;&#27493;&#26356;&#26032;&#25991;&#20214;&#23646;&#24615; </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">fsync</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">filedes</span>);

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#31867;&#20284;fsync,&#20294;&#19981;&#26356;&#26032;&#25991;&#20214;&#23646;&#24615; </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">fdatasync</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">filedes</span>);

<span style="color: #b22222;">/* </span><span style="color: #b22222;">sync&#21482;&#26159;&#23558;&#25152;&#26377;&#20462;&#25913;&#36807;&#30340;&#22359;&#32531;&#20914;&#21306;&#25490;&#20837;&#20889;&#38431;&#21015;,&#28982;&#21518;&#23601;&#36820;&#22238;,&#32780;&#24182;&#31561;&#24453;&#23454;&#38469;&#20889;&#30913;&#30424;&#25805;&#20316;&#32467;&#26463; </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">sync</span>(<span style="color: #228b22;">void</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> fcntl函数</h2>
<div class="outline-text-2" id="text-4">
<p>
fcntl函数可以改变已打开的文件属性,该函数常用于修改由shell代为打开的文件描述符的属性.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;fcntl.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">fcntl</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">filedes</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">cmd</span>);
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">fcntl</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">filedes</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">cmd</span>,<span style="color: #228b22;">long</span> <span style="color: #a0522d;">arg</span>);
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">fcntl</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">filedes</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">cmd</span>,<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">flock</span>* <span style="color: #a0522d;">lock</span>);

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">flock</span>
{
  <span style="color: #228b22;">short</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">l_type</span>;             <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#38145;&#31867;&#22411;:F_RDLCK,F_WRLCK,F_UNLCK </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">short</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">l_whence</span>;           <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#20915;&#23450;l_start&#30340;&#20301;&#32622;:SEEK_SET,SEEK_CUR,SEEK_END </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">off_t</span> <span style="color: #a0522d;">l_start</span>;                <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#38145;&#23450;&#21306;&#22495;&#30340;&#24320;&#22836;&#20301;&#32622; </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">off_t</span> <span style="color: #a0522d;">l_len</span>;                  <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#38145;&#23450;&#21306;&#22495;&#30340;&#22823;&#23567; </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">pid_t</span> <span style="color: #a0522d;">l_pid</span>;                  <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#38145;&#23450;&#25805;&#20316;&#30340;&#36827;&#31243; </span><span style="color: #b22222;">*/</span>
}
</pre>
</div>

<p>
其中fcntl支持的cmd操作有:
</p>
<ul class="org-ul">
<li>复制一个现有的文件描述符(F_DUPFD)
</li>
<li>获得/设置文件描述符标记(F_GETFD/F_SETFD)
</li>
<li>获得/设置文件状态标记(F_GETFL/F_SETFL)
</li>
<li>获得/设置异步IO所有权(F_GETOWN/F_SETOWN)
拥有IO所有权的进程,会收到在该描述符上产生的信号.
</li>
<li>获得/设置记录锁(F_GETLK/F_SETLK/F_SETLKW)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> ioctl函数</h2>
<div class="outline-text-2" id="text-5">
<p>
每个驱动程序都定义了它自己的专门的一组ioctl命令,而系统提供一个统一的ioctl函数来调用这些专门的命令.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;unistd.h&gt;</span>             <span style="color: #b22222;">/* </span><span style="color: #b22222;">System V </span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;sys/ioctl.h&gt;</span>          <span style="color: #b22222;">/* </span><span style="color: #b22222;">BSD and Linux </span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stropts.h&gt;</span>            <span style="color: #b22222;">/* </span><span style="color: #b22222;">XSI STREAMS </span><span style="color: #b22222;">*/</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">ioctl</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">filedes</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">request</span>,...);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> /dev/fd</h2>
<div class="outline-text-2" id="text-6">
<p>
新UNIX系统一般都提供了名为/dev/fd的目录,其中包含0,1,2等文件. 打开文件/dev/fd/n等效于复制描述符n.
</p>
<div class="org-src-container">

<pre class="src src-c">fd = open(<span style="color: #8b2252;">"/dev/fd/n"</span>,mode);
<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#31561;&#25928;&#20110; </span><span style="color: #b22222;">*/</span>
fd = dup(n);
</pre>
</div>

<p>
/dev/fd的主要作用其实时提供给shell使用,它允许使用文件路径名为参数的程序也能处理标准输入输出
<code>=====</code>
</p>
</div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 参数filedes</h3>
<div class="outline-text-3" id="text-6-1">
<p>
filedes参数为待设置的文件描述符
</p>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 参数cmd</h3>
<div class="outline-text-3" id="text-6-2">
<p>
cmd参数表示欲操作的指令
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">F_DUPFD</td>
<td class="left">寻找大于或等于参数arg的最小未使用文件描述符,并复制参数filedes的文件描述符,类似dup2的功能</td>
</tr>

<tr>
<td class="left">F_GETFD</td>
<td class="left">获取close-on-exec标志. 若标志为0,表示调用exec相关函数时文件不关闭</td>
</tr>

<tr>
<td class="left">F_SETFD</td>
<td class="left">设置close-on-exec标志</td>
</tr>

<tr>
<td class="left">F_GETFL</td>
<td class="left">取得文件描述符状态标志,这个标志为open的flag参数</td>
</tr>

<tr>
<td class="left">F_SETFL</td>
<td class="left">设置文件描述符的新状态标志. 但只运行修改 <b>O_APPEND,O_NONBLOCK,O_ASYNC</b></td>
</tr>

<tr>
<td class="left">F_GETLK</td>
<td class="left">取得文件锁状态</td>
</tr>

<tr>
<td class="left">F_SETLK</td>
<td class="left">设置文件锁状态,其中flock.l_type必须是 <b>F_RDLCK,F_WRLCK或F_UNLCK</b>, 若无法锁定,则立即返回-1,errno为EACCESS或EAGAIN</td>
</tr>

<tr>
<td class="left">F_SETLKW</td>
<td class="left">与F_SETLK类似,但若无法建立锁定,则该调用会一直阻塞至成功为止.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 非阻塞IO</h2>
<div class="outline-text-2" id="text-7">
<p>
非阻塞IO使得我们在调用open,read和write这样的IO操作时,若操作不能完成,则直接返回错误提示,而不是阻塞.
</p>
</div>

<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> 指定非阻塞IO的方法</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>调用open获得描述符时,指定`O_NONBLOCK'标志
</li>
<li>使用fcntl对 <b>已打开描述符</b> 修改O_NONBLOCK文件状态标志.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 记录锁</h2>
<div class="outline-text-2" id="text-8">
<p>
所谓记录锁,更合适的术语应该叫`字节范围锁'. 它的功能是,当进程读取或修改文件的 <b>某个部分时</b>,阻止其他进程修改 <b>同一文件区域</b>.
</p>
</div>

<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> fcntl记录锁</h3>
<div class="outline-text-3" id="text-8-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;fcntl.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">fcntl</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">fieldes</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">cmd</span>,<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">flock</span>* <span style="color: #a0522d;">lock</span>);

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">flock</span>
{
  <span style="color: #228b22;">short</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">l_type</span>;             <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#38145;&#31867;&#22411;:F_RDLCK(&#35835;&#38145;),F_WRLCK(&#20889;&#38145;),F_UNLCK(&#35299;&#38145;) </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">short</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">l_whence</span>;           <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#20915;&#23450;l_start&#30340;&#20301;&#32622;:SEEK_SET,SEEK_CUR,SEEK_END </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">off_t</span> <span style="color: #a0522d;">l_start</span>;                <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#38145;&#23450;&#21306;&#22495;&#30340;&#24320;&#22836;&#20301;&#32622; </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">off_t</span> <span style="color: #a0522d;">l_len</span>;                  <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#38145;&#23450;&#21306;&#22495;&#30340;&#22823;&#23567; </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">pid_t</span> <span style="color: #a0522d;">l_pid</span>;                  <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#38145;&#23450;&#25805;&#20316;&#30340;&#36827;&#31243; </span><span style="color: #b22222;">*/</span>
};
</pre>
</div>
<p>
fcntl的锁分读锁和写所,其规则类似线程的rwlock,但它只能影响不同进程提出的锁请求.
</p>

<p>
如果一个进程对一个文件区间加了一把锁,后来该进程又在 <b>同一个文件区间</b> 再加锁,则 <b>新锁替代旧锁</b>
</p>

<p>
加读锁时,该文件描述符必须是读打开的. 加写锁时,该文件描述符是写打开的.
</p>

<p>
<b>在设置/释放文件上的锁时,系统会按要求组合或风儿锁区块</b>. 
例如:一开始对第100&#x2013;199字节加了锁
若又对第150位字节解锁,则内核需要维持两个锁:100-149和151-199. 
若又对150位字节加锁,则系统又合并相邻的三个加锁区为一个区
</p>
</div>
<div id="outline-container-sec-8-1-1" class="outline-4">
<h4 id="sec-8-1-1"><span class="section-number-4">8.1.1</span> cmd操作说明</h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
fcntl中与记录锁相关的cmd操作是`F_GETLK',`F_SETLK',`F_SETLKW'. 且第三个参数为flock类型的指针
</p>
<ul class="org-ul">
<li>F_GETLK

<p>
判断原lock参数描述的区域,是否有一把锁. (<b>但不能用于测试自己进程所加的锁</b>)
</p>

<p>
锁信息会修改原lock参数. 
</p>

<p>
若不存在锁则会将原lock参数中的l_type设为F_UNLCK,lock参数中的其他信息保存不变.
</p>
</li>

<li>F_SETLK

<p>
尝试加由参数lock所描述的锁,若无法加锁,则立即出错返回,且errno设置为EACCES或EAGAIN.
</p>

<p>
若参数lock的l_type为F_UNLCK,则表示解锁
</p>
</li>

<li>F_SETLKW

<p>
这时F_SETLK的阻塞版本.
</p>
</li>
</ul>


<p>
需要注意的是, <b>F_GETLK和F_SETLK/F_SETLKW两个调用之间完全有可能有另一个进程创建了相关锁</b>.
</p>
</div>
</div>
<div id="outline-container-sec-8-1-2" class="outline-4">
<h4 id="sec-8-1-2"><span class="section-number-4">8.1.2</span> flock结构说明</h4>
<div class="outline-text-4" id="text-8-1-2">
<ul class="org-ul">
<li>flock结构中的l_type标明了锁的类型
</li>

<li>要加锁或解锁区域的起始字节偏移量由l_start和l_whence共同决定,类似于lseek函数
</li>

<li>起始字节偏移量 <b>可以为文件尾端或越过文件尾端,但不能在文件起始位置之前开始</b>
</li>

<li>加锁/解锁的字节长度由l_len表示,但0表示锁的区域 <b>无穷大</b>
</li>

<li>持有锁的进程由l_pid表示
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> 关于锁的释放与继承</h3>
<div class="outline-text-3" id="text-8-2">
</div><div id="outline-container-sec-8-2-1" class="outline-4">
<h4 id="sec-8-2-1"><span class="section-number-4">8.2.1</span> 锁的释放</h4>
<div class="outline-text-4" id="text-8-2-1">
<ul class="org-ul">
<li>当进程终止时,该进程所建立的锁全部释放
</li>

<li>当关闭一个文件描述符时,所有与该文件描述符 <b>指向同一个文件</b> 的相关锁全部被释放. 即
<div class="org-src-container">

<pre class="src src-C">fd1 = open(pathname,...);
fd2 = dup(fd1);                 <span style="color: #b22222;">/* </span><span style="color: #b22222;">fd1&#21644;fd2&#25351;&#21521;&#21516;&#19968;&#20010;&#25991;&#20214; </span><span style="color: #b22222;">*/</span>
close(fd2);                     <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#27492;&#26102;,fd1&#19978;&#35774;&#32622;&#30340;&#38145;&#20063;&#20250;&#34987;&#37322;&#25918; </span><span style="color: #b22222;">*/</span>


fd1 = open(pathname,...);
fd2 = open(pathname,...);       <span style="color: #b22222;">/* </span><span style="color: #b22222;">fd1&#21644;fd2&#20063;&#26159;&#25351;&#21521;&#21516;&#19968;&#20010;&#25991;&#20214; </span><span style="color: #b22222;">*/</span>
close(fd2);                     <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#27492;&#26102;,fd1&#19978;&#35774;&#32622;&#30340;&#38145;&#20063;&#20250;&#34987;&#37322;&#25918; </span><span style="color: #b22222;">*/</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-2-2" class="outline-4">
<h4 id="sec-8-2-2"><span class="section-number-4">8.2.2</span> 锁的继承</h4>
<div class="outline-text-4" id="text-8-2-2">
<ul class="org-ul">
<li>fork产生的子进程不继承父进程所设置的锁.

<p>
因为子进程已经是另一个进程了.
</p>
</li>

<li><b>执行exec后,进程继承原程序的锁</b>

<p>
因此exec后,进程id没变.
</p>

<p>
但若文件描述符设置了close-on-exec标志,则由于exec时会关闭文件标识符,因此对应文件的锁都会被释放
</p>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> 建议性锁和强制性锁</h3>
<div class="outline-text-3" id="text-8-3">
<p>
一个文件加锁时是使用建议性锁还是强制性锁,是由文件本身的权限决定的. 若文件打开了其设置组ID位并关闭了组的执行位,则表示文件开启的是强制性锁机制(之所以这样设计是因为当组执行位关闭时,设置组ID位不再有意义).
</p>

<p>
当使用建设性锁时,它无法阻止其他进程直接对文件进行读写. 它的实现有赖于其他进程在读写前自我的对锁进行检测.
</p>

<p>
而强制锁使内核对任何open,read和write系统调用进行检查. <b>但强制锁对unlink函数无影响!</b>
</p>
</div>
</div>
<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> flock文件锁</h3>
<div class="outline-text-3" id="text-8-4">
<p>
flock只能对锁定整个文件而无法锁定某个区域
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;sys/file.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">flock</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">fd</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">operatioon</span>);
</pre>
</div>
<p>
参数operatiion可以为:
</p>
<dl class="org-dl">
<dt> LOCK_SH </dt><dd>共享锁
</dd>
<dt> LOCK_EX </dt><dd>排它锁
</dd>
<dt> LOCK_UN </dt><dd>解锁
</dd>
<dt> LOCK_NB </dt><dd>无法加锁时,立即返回不阻塞.
</dd>
</dl>

<p>
<b>当使用dup()或fork()时,文件描述符不会继承这种锁定</b>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> IO多路转换</h2>
<div class="outline-text-2" id="text-9">
<p>
IO多路转换需要先构造一张描述符的列表,然后调用一个函数,该函数直到这些描述符中的一个已经准备好IO时,才返回.
</p>

<p>
poll,pselect和select这三个函数使得我们能够执行IO多路转换,并返回哪些描述符已经准备好进行IO了.
</p>
</div>
<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> select</h3>
<div class="outline-text-3" id="text-9-1">
<p>
传给select的参数告诉内核:
</p>
<ul class="org-ul">
<li>我们关心哪些描述符
</li>
<li>对于每个描述符,我们所关心的条件是什么(想读?想写?发生异常条件?)
</li>
<li>原意等待多久(一直等待,等待某个时间段,不等待)
</li>
</ul>

<p>
select返回时的到的消息包括:
</p>
<ul class="org-ul">
<li>已准备好的描述符的总数量
</li>
<li>对于读,写或异常这3个条件中的每一个,分别有哪些描述符准备好了.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;sys/select.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#36820;&#22238;&#20934;&#22791;&#23601;&#32490;&#30340;&#25551;&#36848;&#31526;&#25968;&#30446;,&#33509;&#36229;&#26102;&#21017;&#36820;&#22238;0,&#33509;&#20986;&#38169;&#36820;&#22238;-1 </span><span style="color: #b22222;">*/</span>
<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#33509;&#19981;&#21516;fd_set&#20013;&#21253;&#21547;&#21516;&#19968;&#20010;&#23601;&#32490;&#30340;fd,&#21017;&#36820;&#22238;&#20540;&#20250;&#37325;&#22797;&#32047;&#21152; </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">select</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">maxfdp</span>,<span style="color: #228b22;">fd_set</span>* <span style="color: #a0522d;">readfds</span>,<span style="color: #228b22;">fd_set</span>* <span style="color: #a0522d;">writefds</span>,<span style="color: #228b22;">fd_set</span>* <span style="color: #a0522d;">exceptfds</span>,<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">timeval</span>* <span style="color: #a0522d;">tvptr</span>);
</pre>
</div>
</div>
<div id="outline-container-sec-9-1-1" class="outline-4">
<h4 id="sec-9-1-1"><span class="section-number-4">9.1.1</span> 时间参数tvptr意义说明:</h4>
<div class="outline-text-4" id="text-9-1-1">
<p>
select函数等待tvptr时间,若时间内有描述符准备好则返回准备好描述符的数量. 若超时则返回0.
</p>

<p>
若捕捉到一个信号,则select返回-1,errno设置为EINTR.
</p>

<p>
tvptr == NULL表示无限等待.
</p>

<p>
<b>select返回后,有可能会修改tvptr表示超时时间未到期的剩余时间值</b>
</p>
</div>
</div>
<div id="outline-container-sec-9-1-2" class="outline-4">
<h4 id="sec-9-1-2"><span class="section-number-4">9.1.2</span> fd_set数据类型说明</h4>
<div class="outline-text-4" id="text-9-1-2">
<p>
使用fd_set数据类型,唯一可进行的处理就是同类型之间的变量进行赋值,或者使用一下四个函数修改数据值
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;sys/select.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#21028;&#26029;fd&#26159;&#21542;&#22312;fd_set&#20013; </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">FD_ISSET</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">fd</span>,<span style="color: #228b22;">fd_set</span>* <span style="color: #a0522d;">fdset</span>);

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#20174;fd_set&#20013;&#21024;&#38500;&#35843;fd </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">FD_CLR</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">fd</span>,<span style="color: #228b22;">fd_set</span>* <span style="color: #a0522d;">fdset</span>);

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#28155;&#21152;fd&#21040;fd_set&#20013; </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">FD_SET</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">fd</span>,<span style="color: #228b22;">fd_set</span>* <span style="color: #a0522d;">fdset</span>);

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#28165;&#31354;fset </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">FD_ZERO</span>(<span style="color: #228b22;">fd_set</span>* <span style="color: #a0522d;">fdset</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9-1-3" class="outline-4">
<h4 id="sec-9-1-3"><span class="section-number-4">9.1.3</span> fd_set*三个参数说明</h4>
<div class="outline-text-4" id="text-9-1-3">
<p>
select函数会修改各fd_set值,使得他们只保留准备好的fd.
</p>

<p>
<b>即使莫描述符上的文件指针已经到达尾部,但select依然认为该描述符是可读的,只不过read会返回0而已</b> (很多人错误第认为,当到达文件尾端时,select会指示一个异常条件)
</p>

<p>
fd_set*的参数值可以为NULL,表表示不关心响应条件
</p>

<p>
<b>三个指针可以都是NULL,则select提供了比sleep更精确的定时器(sleep精确到秒,select精确到微秒)</b>
</p>
</div>
</div>
<div id="outline-container-sec-9-1-4" class="outline-4">
<h4 id="sec-9-1-4"><span class="section-number-4">9.1.4</span> 参数maxfdp说明</h4>
<div class="outline-text-4" id="text-9-1-4">
<p>
该参数一般为三个fd_set中最大fd的值+1(加1的原因在于描述符编号从0开始). 它的意义在于提供給select函数一个搜索fd的范围. 使得内核不用搜索fd_Set中数百个无用的fd.
</p>

<p>
一般&lt;sys/select.h&gt;中定义了一个常量FD_SETSIZE,该常量的值表示允许的最大描述符.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> pselect</h3>
<div class="outline-text-3" id="text-9-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;sys/select.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#36820;&#22238;&#23601;&#32490;&#30340;&#25551;&#36848;&#31526;&#24635;&#25968;,&#36229;&#26102;&#21017;&#36820;&#22238;0,&#20986;&#38169;&#21017;&#36820;&#22238;-1 </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">pselect</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">maxfdp</span>,
            <span style="color: #228b22;">fd_set</span>* <span style="color: #a0522d;">readfds</span>,
            <span style="color: #228b22;">fd_set</span>* <span style="color: #a0522d;">writefds</span>,
            <span style="color: #228b22;">fd_set</span>* <span style="color: #a0522d;">exceptfds</span>,
            <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">timespec</span>*<span style="color: #a0522d;">tsptr</span>,
            <span style="color: #a020f0;">const</span> <span style="color: #228b22;">sigset_t</span>* <span style="color: #a0522d;">sigmask</span>);
</pre>
</div>
</div>

<div id="outline-container-sec-9-2-1" class="outline-4">
<h4 id="sec-9-2-1"><span class="section-number-4">9.2.1</span> pselect与select的不同之处</h4>
<div class="outline-text-4" id="text-9-2-1">
<ul class="org-ul">
<li>select用timeval结构指定超时,而pselect用timespec结构指定超时. timespec能提供更精确的超时时间
</li>

<li>pselect的超时值为const,这保证了pselect不会改变次值
</li>

<li>若参数sigmask为非NULL,则pselect可以原子操作的方式安装该信号屏蔽字,返回时恢复以前的信号屏蔽字.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3"><span class="section-number-3">9.3</span> 函数poll</h3>
<div class="outline-text-3" id="text-9-3">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;poll.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#36820;&#22238;&#20934;&#22791;&#23601;&#32490;&#30340;&#25551;&#36848;&#31526;&#25968;&#30446;,&#33509;&#36229;&#26102;&#36820;&#22238;0,&#20986;&#38169;&#21017;&#36820;&#22238;-1 </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">poll</span>(<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">pollfd</span> <span style="color: #a0522d;">fdarray</span>[],<span style="color: #228b22;">nfds_t</span> <span style="color: #a0522d;">nfds</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">timeout</span>);
</pre>
</div>
<p>
poll函数的作用类似select,但poll并不是为每个条件(读,写,异常)构造一个描述符集合. 
</p>

<p>
poll是构造一个pollfd结构的数组. 每个pollfd结构体指定了一个描述符编号以及我们对描述符感兴趣的条件
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">pollfd</span>
{
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">fd</span>;                       <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#35201;&#26816;&#27979;&#30340;&#25991;&#20214;&#25551;&#36848;&#31526; </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">short</span> <span style="color: #a0522d;">events</span>;                 <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#20851;&#27880;&#25991;&#20214;&#25551;&#36848;&#31526;&#19978;&#30340;&#21738;&#20123;&#20107;&#20214; </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">short</span> <span style="color: #a0522d;">revents</span>;                <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#20989;&#25968;&#36820;&#22238;&#26102;,&#34987;&#20462;&#25913;&#20026;&#35813;&#25551;&#36848;&#31526;&#21457;&#29983;&#20102;&#21738;&#20123;&#20107;&#20214; </span><span style="color: #b22222;">*/</span>
}
</pre>
</div>
</div>

<div id="outline-container-sec-9-3-1" class="outline-4">
<h4 id="sec-9-3-1"><span class="section-number-4">9.3.1</span> poll中的事件说明</h4>
<div class="outline-text-4" id="text-9-3-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">标志名</th>
<th scope="col" class="left">是否可设置为events</th>
<th scope="col" class="left">是否可设置为revents</th>
<th scope="col" class="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">POLLIN</td>
<td class="left">是</td>
<td class="left">是</td>
<td class="left">可以不阻塞地读高优先级数据以外的数据</td>
</tr>

<tr>
<td class="left">POLLRDNORM</td>
<td class="left">是</td>
<td class="left">是</td>
<td class="left">可以不阻塞地读普通数据</td>
</tr>

<tr>
<td class="left">POLLRDBAND</td>
<td class="left">是</td>
<td class="left">是</td>
<td class="left">可以不阻塞地读优先级数据</td>
</tr>

<tr>
<td class="left">POLLPRI</td>
<td class="left">是</td>
<td class="left">是</td>
<td class="left">可以不阻塞地读高优先级数据</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">POLLOUT</td>
<td class="left">是</td>
<td class="left">是</td>
<td class="left">可以不阻塞第写普通数据</td>
</tr>

<tr>
<td class="left">POLLWRNORM</td>
<td class="left">是</td>
<td class="left">是</td>
<td class="left">与POLLOUT相同</td>
</tr>

<tr>
<td class="left">POLLWRBAND</td>
<td class="left">是</td>
<td class="left">是</td>
<td class="left">可以不阻塞第写优先级数据</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">POLLERR</td>
<td class="left">否</td>
<td class="left">是</td>
<td class="left">已出错</td>
</tr>

<tr>
<td class="left">POLLHUP</td>
<td class="left">否</td>
<td class="left">是</td>
<td class="left">已挂断(制解调器被挂断)</td>
</tr>

<tr>
<td class="left">POLLNVAL</td>
<td class="left">否</td>
<td class="left">是</td>
<td class="left">描述符没有引用一个打开文件.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-9-3-2" class="outline-4">
<h4 id="sec-9-3-2"><span class="section-number-4">9.3.2</span> timeout说明</h4>
<div class="outline-text-4" id="text-9-3-2">
<ul class="org-ul">
<li>timeout == -1表示一直等待
</li>
<li>timeout == 0表示不等待
</li>
<li>timeout &gt; 0表示等待timeout <b>毫秒</b>
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> POSIX异步IO</h2>
<div class="outline-text-2" id="text-10">
<p>
执行IO操作时,如果还有其他事务需要处理而不想被IO操作阻塞,就可以使用异步IO.
</p>

<p>
异步IO接口使用AIO控制块来描述IO操作. aiocb定义了AIO控制块
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">aiocb</span>
{
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">aio_fildes</span>;               <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#25991;&#20214;&#25551;&#36848;&#31526; </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">off_t</span> <span style="color: #a0522d;">aio_offset</span>;             <span style="color: #b22222;">/* </span><span style="color: #b22222;">IO&#25805;&#20316;&#26102;&#30340;&#25991;&#20214;&#20559;&#31227;&#37327; </span><span style="color: #b22222;">*/</span>
  <span style="color: #a020f0;">volatile</span> <span style="color: #228b22;">void</span>* <span style="color: #a0522d;">aio_buffer</span>;    <span style="color: #b22222;">/* </span><span style="color: #b22222;">IO&#25805;&#20316;&#29992;&#30340;&#32531;&#20914;&#21306; </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">aio_nbytes</span>;            <span style="color: #b22222;">/* </span><span style="color: #b22222;">IO&#25805;&#20316;&#20256;&#36755;&#30340;&#23383;&#33410;&#25968; </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">aio_reqprio</span>;              <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#20248;&#20808;&#32423; </span><span style="color: #b22222;">*/</span>
  <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">sigevent</span> <span style="color: #a0522d;">aio_sigevent</span>; <span style="color: #b22222;">/* </span><span style="color: #b22222;">IO&#23436;&#25104;&#21518;&#36890;&#30693;&#36827;&#31243;&#30340;&#26041;&#24335; </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">aio_lio_opcode</span>;           <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#35843;&#29992;lio_listio&#20989;&#25968;&#26102;&#20351;&#29992; </span><span style="color: #b22222;">*/</span>
};
</pre>
</div>
<ul class="org-ul">
<li>aio_fields字段表示被打开用来读或写的文件描述符
</li>
<li>读或写的操作从aio_offset指定的偏移量开始.
</li>
<li><b>异步I/O操作必须显式地指定偏移量,异步I/O接口并不影响由操作系统维护的文件偏移量,但若使用异步IO接口向一个O_APPEND模式打开的文件写入数据,则aio_offset字段会被系统忽略</b>
</li>
<li>读写时的缓冲区由aio_buf指定,aio_nbytes字段表明了要读/写的字节数
</li>
<li>aio_sigevent字段控制IO事件完成后,如何通知应用程序.
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">sigevent</span>
{
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">sigev_notify</span>;             <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#36890;&#30693;&#30340;&#31867;&#22411; </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">int</span> <span style="color: #a0522d;">sigev_signo</span>;              <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#20449;&#21495;&#32534;&#30721; </span><span style="color: #b22222;">*/</span>
  <span style="color: #a020f0;">union</span> <span style="color: #228b22;">sigval</span> <span style="color: #a0522d;">sigev_value</span>;     <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#20256;&#36882;&#32473;&#36890;&#30693;&#20989;&#25968;&#30340;&#21442;&#25968; </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">void</span> (*<span style="color: #0000ff;">sigev_notify_function</span>)(<span style="color: #a020f0;">union</span> <span style="color: #228b22;">sigval</span>); <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#36890;&#30693;&#20989;&#25968; </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">pthread_attr_t</span>* <span style="color: #a0522d;">sigev_notify_attributes</span>;     <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#35843;&#29992;&#36890;&#30693;&#20989;&#25968;&#30340;&#32447;&#31243;&#23646;&#24615;,&#40664;&#35748;&#20250;&#22312;&#20998;&#31163;&#29366;&#24577;&#19979;&#30340;&#32447;&#31243;&#20013;&#35843;&#29992;&#36890;&#30693;&#20989;&#25968; </span><span style="color: #b22222;">*/</span>
};
</pre>
</div>

<p>
其中sigev_notify字段控制通知的类型,取值可能是一下3个中的一个:
</p>
<ul class="org-ul">
<li>SIGEV_NONE

<p>
异步IO请求后不通知进程
</p>
</li>

<li>SIGEV_SIGNAL

<p>
异步IO完成后产生 <b>sigev_signo</b> 字段指定的信号.
</p>
</li>

<li>SIGEV_THREAD

<p>
异步IO完成后,在单独的线程中执行sigev_notify_function字段指定的函数.
</p>

<p>
sigev_value字段为该函数的唯一参数.
</p>

<p>
sigev_notify_attribute字段表示调用通知函数线程的属性,为NULL,则通知函数在 <b>分离状态</b> 下的一个i额单独的线程中执行.
</p>
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> 异步读写操作</h3>
<div class="outline-text-3" id="text-10-1">
<p>
在进行异步IO之前需要先初始化AIO控制块,然后调用aio_read函数进行异步读操作,或调用aio_write函数来进行异步写操作
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;aio.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#25104;&#21151;&#36820;&#22238;0,&#20986;&#38169;&#36820;&#22238;-1 </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">aio_read</span>(<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">aiocb</span>* <span style="color: #a0522d;">aiocb</span>);

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#25104;&#21151;&#36820;&#22238;0,&#20986;&#38169;&#36820;&#22238;-1 </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">aio_write</span>(<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">aiocb</span>* <span style="color: #a0522d;">aiocb</span>);
</pre>
</div>
<p>
<b>这些函数的返回仅表示IO请求已经被操作系统放入等待处理的队列中了,而与实际IO操作结果没有任何关系</b>
</p>

<p>
<b>在IO操作等待期间,需保证AIO控制块与其定义的缓冲区的内容不会被更改!!</b>,除非IO操作完成,否则不能被复用.
</p>

<p>
lio_listio函数既能以同步的方式来使用,也能以异步的方式来使用. 该函数会提交一系列由一个AIO控制块列表描述的IO请求.
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;aio.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">lio_listio</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">mode</span>,<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">aiocb</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">list</span>[],<span style="color: #228b22;">int</span> <span style="color: #a0522d;">n</span>,<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">sigevent</span>* <span style="color: #a0522d;">sigev</span>);
</pre>
</div>
<ul class="org-ul">
<li>mode参数决定了IO是否为异步的.
<dl class="org-dl">
<dt> LIO_WAIT </dt><dd>函数将在所有由列表指定的IO操作完成后返回,这是sigev参数将被忽略
</dd>
<dt> LIO_NOWAIT </dt><dd>函数将在IO请求入队后立即返回.
</dd>
</dl>
</li>
<li>sigev参数指定了异步IO操作完成后如何被异步地通知. 若不想被通知可以设为NULL
每个AIO控制块本身也有操作完后的异步通知模式, <b>被sigev参数之i都能过的异步通知是在此之外另加的,且只会在所有的IO操作都完成后才发送</b>
</li>
<li>list参数指向一个AIO控制块指针的数组,该列表指定了要运行的IO操作. list中可以包含NULL指针,这些条目将被忽略
</li>
<li>每个AIO操作块中的aio_lio_opcode字段指明了要进行的操作
<dl class="org-dl">
<dt> LIO_READ </dt><dd>读操作
</dd>
<dt> LIO_WRITE </dt><dd>写操作
</dd>
<dt> LIO_NOP </dt><dd>空操作
</dd>
</dl>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> 强制同步</h3>
<div class="outline-text-3" id="text-10-2">
<p>
要强制等待中的异步操作立即同步到存储中,可以设立一个AIO控制块,并调用aio_fsync函数
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;aio.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">aio_fsync</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">op</span>,<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">aiocb</span>* <span style="color: #a0522d;">aiocb</span>);
</pre>
</div>
<p>
AIO控制块中的aio_fildes字段指明了其异步写操作被同步的文件.
</p>

<p>
若op参数为D_SYNC,那么类似于fdatasync. 若op参数为O_SYNC,那么类似于fsync
</p>

<p>
类似aio_read和aio_write,aio_fsync <b>仅仅表示同步请求已经被操作系统放入等待处理的队列中了</b>. 在异步同步操作完成前,数据不会真正的写入存储中. AIO控制块也控制了我们被通知的方式.
</p>
</div>
</div>

<div id="outline-container-sec-10-3" class="outline-3">
<h3 id="sec-10-3"><span class="section-number-3">10.3</span> 获取异步读,写,同步操作的完成状态</h3>
<div class="outline-text-3" id="text-10-3">
<p>
为了获取一个异步读,写或同步操作的完成状态,需要调用aio_error函数
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;aio.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">aio_error</span>(<span style="color: #a020f0;">const</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">aiocb</span>* <span style="color: #a0522d;">aiocb</span>);
</pre>
</div>
<p>
关于返回值的说明为:
</p>
<dl class="org-dl">
<dt> 0 </dt><dd>异步操作成功完成,需要调用aio_return函数获取操作返回值
</dd>
<dt> -1 </dt><dd>对aio_error的调用失败,可以通过errno了解失败原因
</dd>
<dt> EINPROGRESS </dt><dd>异步读,写或同步操作仍在等待.
</dd>
<dt> 其他情况 </dt><dd>相关异步操作失败返回的错误码
</dd>
</dl>

<p>
如果异步操作成功,可以调用aio_return函数来获取异步操作的返回值
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;aio.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">aio_return&#20989;&#25968;&#26412;&#36523;&#22833;&#36133;&#36820;&#22238;-1,&#24182;&#35774;&#32622;errno.</span>
<span style="color: #b22222;">   &#21542;&#21017;&#36820;&#22238;&#24322;&#27493;&#25805;&#20316;&#30340;&#32467;&#26524;</span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">ssize_t</span> <span style="color: #0000ff;">aio_return</span>(<span style="color: #a020f0;">const</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">aiocb</span>* <span style="color: #a0522d;">aiocb</span>);
</pre>
</div>
<ul class="org-ul">
<li>异步操作完成之前,都要小心不要调用aio_return函数. 此时的结果是未定义的.
</li>
<li>对每个异步操作 <b>仅调用一次aio_return</b>. 一旦调用该函数,操作系统就可能释放掉包含IO操作返回值的记录.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-10-4" class="outline-3">
<h3 id="sec-10-4"><span class="section-number-3">10.4</span> 异步操作管理</h3>
<div class="outline-text-3" id="text-10-4">
<p>
若完成要操作的事务后,还有异步操作未完成,可以调用aio_suspend函数来 <b>阻塞进程</b>.直到操作完成
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;aio.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#33509;&#35813;&#20989;&#25968;&#34987;&#20449;&#21495;&#32456;&#31471;,&#21017;&#36820;&#22238;-1,&#19988;errno&#20026;EINTR </span><span style="color: #b22222;">*/</span>
<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#33509;timeout&#26102;&#38388;&#20869;&#27809;&#26377;&#20219;&#20309;IO&#25805;&#20316;&#23436;&#25104;,&#21017;&#36820;&#22238;-1,&#19988;errno&#20026;EAGAIN </span><span style="color: #b22222;">*/</span>
<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#33509;timeout&#26102;&#38388;&#20869;,list&#25968;&#32452;&#20013;&#26377;&#20219;&#20309;&#19968;&#20010;&#24322;&#27493;&#25805;&#20316;&#23436;&#25104;,&#21017;&#36820;&#22238;0 </span><span style="color: #b22222;">*/</span>
<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#33509;&#35843;&#29992;aio_suspend&#25805;&#20316;&#26102;,&#25152;&#26377;&#30340;&#24322;&#27493;IO&#25805;&#20316;&#37117;&#24050;&#23436;&#25104;,&#37027;&#20040;aio_suspend&#23558;&#22312;&#19981;&#38459;&#22622;&#30340;&#24773;&#20917;&#19979;&#30452;&#25509;&#36820;&#22238; </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">aio_suspend</span>(<span style="color: #a020f0;">const</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">aiocb</span>* <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">list</span>[],<span style="color: #228b22;">int</span> <span style="color: #a0522d;">nent</span>,<span style="color: #a020f0;">const</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">timespec</span>* <span style="color: #a0522d;">timeout</span>);
</pre>
</div>
<ul class="org-ul">
<li>list参数是一个指向AIO控制块数组的指针,nent参数指明了检查数组中的几个AIO控制块.
</li>
<li><b>若list数组中有NULL元素,则检查时会被跳过</b>
</li>
</ul>

<p>
若我们不想再完成等待中的异步IO,可以使用aio_cancel函数取消之
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;aio.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">AIO_ALLDONE:&#25152;&#26377;&#25805;&#20316;&#22312;&#23581;&#35797;&#21462;&#28040;&#20182;&#20204;&#21069;&#23601;&#24050;&#32463;&#23436;&#25104; </span><span style="color: #b22222;">*/</span>
<span style="color: #b22222;">/* </span><span style="color: #b22222;">AIO_CANCELED:&#25152;&#26377;&#35201;&#27714;&#30340;&#25805;&#20316;&#24050;&#32463;&#34987;&#21462;&#28040; </span><span style="color: #b22222;">*/</span>
<span style="color: #b22222;">/* </span><span style="color: #b22222;">AIO_NOTCANCELED:&#33267;&#23569;&#26377;&#19968;&#20010;&#35201;&#27714;&#30340;&#25805;&#20316;&#27809;&#26377;&#34987;&#21462;&#28040; </span><span style="color: #b22222;">*/</span>
<span style="color: #b22222;">/* </span><span style="color: #b22222;">-1 : &#23545;aio_cancel&#35843;&#29992;&#22833;&#36133;,&#38169;&#35823;&#30721;&#23384;&#20648;&#22312;errno&#20013; </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">aio_cancel</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">fd</span>,<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">aioch</span>* <span style="color: #a0522d;">aiocb</span>);
</pre>
</div>
<ul class="org-ul">
<li>参数fd指定了那个未完成的异步IO操作的文件描述符
</li>
<li>若参数aiocb参数为NULL,系统会尝试取消所有该文件上未完成的异步IO操作
</li>
<li>其他情况下,系统将尝试取消由AIO控制块描述的单个异步IO操作.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 散布读(scatter read)和聚集写(gather write)</h2>
<div class="outline-text-2" id="text-11">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;sys/uio.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#36820;&#22238;&#25152;&#26377;&#24050;&#35835;&#30340;&#23383;&#33410;&#25968; </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">ssize_t</span> <span style="color: #0000ff;">readv</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">fd</span>,<span style="color: #a020f0;">const</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">iovec</span>* <span style="color: #a0522d;">iov</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">iovcnt</span>);

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#36820;&#22238;&#25152;&#26377;&#24050;&#20889;&#30340;&#23383;&#33410;&#25968; </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">sszie_t</span> <span style="color: #0000ff;">writev</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">fd</span>,<span style="color: #a020f0;">const</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">iovec</span>* <span style="color: #a0522d;">iov</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">iovcnt</span>);

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">iovec</span>
{
  <span style="color: #228b22;">void</span>* <span style="color: #a0522d;">iov_base</span>;               <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#32531;&#20914;&#21306;&#30340;&#22320;&#22336; </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">iov_len</span>;               <span style="color: #b22222;">/* </span><span style="color: #b22222;">&#32531;&#20914;&#21306;&#30340;&#22823;&#23567; </span><span style="color: #b22222;">*/</span>
};
</pre>
</div>
<ul class="org-ul">
<li>readv允许一次从一个文件中读取内容存放到多个缓冲区中. 此为散布读
</li>

<li>writev允许一次将多个缓冲区中的内容写入到一个文件中. 此为聚集写
</li>

<li>iov数组内的元素数由iovcnt指定,其最大值为IOV_MAX
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> 存储映射IO</h2>
<div class="outline-text-2" id="text-12">
<p>
存储映射IO能将一个磁盘文件映射到内存的一个缓冲区中,这样从缓冲区中读取数据就相当于读文件中的相应字节. 将数据存入缓冲区时,相应字节就自动写入文件. 这样就可以在不使用read和write的情况下执行IO
</p>
</div>

<div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1"><span class="section-number-3">12.1</span> 将文件映射到缓冲区</h3>
<div class="outline-text-3" id="text-12-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;sys/mman.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#33509;&#25104;&#21151;,&#36820;&#22238;&#26144;&#23556;&#21306;&#30340;&#36215;&#22987;&#22320;&#22336;;&#33509;&#20986;&#38169;&#36820;&#22238;MAP_FAILED </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">void</span>* <span style="color: #0000ff;">mmap</span>(<span style="color: #228b22;">void</span>* <span style="color: #a0522d;">addr</span>,<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">prot</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">flag</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">fd</span>,<span style="color: #228b22;">off_t</span> <span style="color: #a0522d;">off</span>);
</pre>
</div>
<ul class="org-ul">
<li>addr参数用于指定映射缓冲区的地址,NULL表示由系统选择
</li>
<li>fd参数指定了要被映射文件的描述符, <b>在文件映射前必须先打开该文件</b>
</li>
<li>len参数指定了要映射的字节数
</li>
<li>off参数为要映射字节在文件中的起始偏移量
</li>
<li>prot参数指定了映射缓冲区的保护要求
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">prot</th>
<th scope="col" class="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">PROT_READ</td>
<td class="left">映射区可读</td>
</tr>

<tr>
<td class="left">PROT_WRITE</td>
<td class="left">映射区可写</td>
</tr>

<tr>
<td class="left">PROT_EXEC</td>
<td class="left">映射区可执行??</td>
</tr>

<tr>
<td class="left">PROT_NONE</td>
<td class="left">映射区不可访问</td>
</tr>
</tbody>
</table>

<p>
可见prot参数指定为PROT_NONE,也可指定为PROT_READ,PROT_WRITE,PROT_EXEC的任意组合,但 <b>并不能超过文件open时的模式访问权限</b>
</p>
</li>
<li>flag参数影响映射缓冲区时的多种属性
<ul class="org-ul">
<li>MAP_FIXED

<p>
映射的缓冲区地址必须为参数addr表示的地址,不利于可移植性,所以不鼓励使用该标志.
</p>

<p>
如果未指定此标志,且addr非NULL,则内核实际只是把addr视为在何处设置映射区的一种 <b>建议</b>
</p>
</li>

<li>MAP_SHARED

<p>
该标志说明对缓冲区作的修改也会映射回原文件. 但这种修改并不会立即写回文件中,具体的时间由系统决定. 且写回时是 <b>整个页</b> 被写回.
</p>

<p>
mmap函数必须指定MAP_SHARED或MAP_PRIVATE标志,但不能同时指定两者
</p>
</li>

<li>MAP_PRIVATE

<p>
该标志说明,对映射区的存储操作只是创建原映射文件的一个副本,所有后来对该映射区的引用都是引用该副本.(即任何修改只影响副本,而不影响原文件,常用于调试)
</p>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-12-2" class="outline-3">
<h3 id="sec-12-2"><span class="section-number-3">12.2</span> 更改映射权限</h3>
<div class="outline-text-3" id="text-12-2">
<p>
调用mprotect函数可以更改一个现有映射的权限
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;sys/mman.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#25104;&#21151;&#36820;&#22238;0,&#20986;&#38169;&#36820;&#22238;-1 </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">mprotect</span>(<span style="color: #228b22;">void</span>* <span style="color: #a0522d;">addr</span>,<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">prot</span>);
</pre>
</div>
<p>
其中prot参数的说明与mmap函数中的说明一样
</p>
</div>
</div>

<div id="outline-container-sec-12-3" class="outline-3">
<h3 id="sec-12-3"><span class="section-number-3">12.3</span> 写回修改到源文件</h3>
<div class="outline-text-3" id="text-12-3">
<p>
如果缓冲区是通过MAP_SHARED标志打开的,则对缓冲区的修改并不会立即写回文件中,具体的时间由系统决定. 
</p>

<p>
那么可以调用msync将修改强制写回原文件.
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;sys/mman.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">&#33509;&#25104;&#21151;,&#36820;&#22238;0;&#33509;&#20986;&#38169;,&#36820;&#22238;-1 </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">msync</span>(<span style="color: #228b22;">void</span>* <span style="color: #a0522d;">addr</span> ,<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">flags</span>);
</pre>
</div>
</div>

<div id="outline-container-sec-12-3-1" class="outline-4">
<h4 id="sec-12-3-1"><span class="section-number-4">12.3.1</span> flags参数说明</h4>
<div class="outline-text-4" id="text-12-3-1">
<ul class="org-ul">
<li>MS_ASYNC 

<p>
采用异步的方式写入原文件,即不用等待写操作完成就返回,必须要指定MS_ASYNC和MS_SYNC中的其中一个.
</p>
</li>

<li>MS_SYNC

<p>
采用同步的方式写入原文件,只有写操作完成后函数才返回,必须要指定MS_ASYNC和MS_SYNC中的其中一个.
</p>
</li>

<li>MS_INVALIDATE

<p>
MS_INVALIDATE asks to invalidate other mappings of the same file (so that they can be updated with the fresh values just written).
</p>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-12-4" class="outline-3">
<h3 id="sec-12-4"><span class="section-number-3">12.4</span> 解除映射</h3>
<div class="outline-text-3" id="text-12-4">
<p>
当进程终止时,会自动解除存储映射区的映射,或者直接调用munmap函数也可以解除映射区. 
但 <b>关闭映射存储区使用的文件描述符并不解除映射区</b>
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;sys/mman.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">munmap</span>(<span style="color: #228b22;">void</span>* <span style="color: #a0522d;">addr</span>,<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">len</span>);
</pre>
</div>
<p>
<b>调用munmap并不会使映射区的内容写到磁盘文件上</b>
</p>
</div>
</div>

<div id="outline-container-sec-12-5" class="outline-3">
<h3 id="sec-12-5"><span class="section-number-3">12.5</span> 相关信号</h3>
<div class="outline-text-3" id="text-12-5">
<p>
与映射区相关的信号有SIGSEGV和SIGBUS.
</p>

<p>
SIGSEGV信用通常用于表明进程试图访问不可用的存储区,或尝试对只读存储区进行写操作.
</p>

<p>
当映射区的某个部分在访问时(原文件被其他进程截断)已不存在,则产生SIGBUS信号.
</p>
</div>
</div>

<div id="outline-container-sec-12-6" class="outline-3">
<h3 id="sec-12-6"><span class="section-number-3">12.6</span> 关于子进程的共享问题</h3>
<div class="outline-text-3" id="text-12-6">
<p>
子进程能通过fork继承存储映射区,但exec后则存储映射区被重置
</p>
</div>
</div>
</div>

</div>
</div>
<div>
  <div class="post-meta">
    <span title="post date" class="post-info">2015-05-13</span>
    <span title="last modification date" class="post-info">2016-01-23</span>
    <span title="tags" class="post-info">:N/A:</span>
    <span title="author" class="post-info"><a href="mailto:Administrator@PC-201510071640">DarkSun</a></span>
  </div>
  <script src="http://lujun9972.github.io/media/js/jquery-2.1.3.min.js"></script>
  <section>
    <h1>Comments</h1>
    <div id="comment-wrap">
      <a class="disqus_label">使用 Disqus 评论</a>
      <a class="ds-label">使用多说评论</a>
    </ul>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
     //var disqus_developer = 1;
     var preempt_signal=false;
     var disqus_identifier = "/blog/2015/05/13/文件io/";
     var disqus_url = "http://lujun9972.github.io/blog/2015/05/13/文件io/";
     var disqus_shortname = 'lujun9972';
     /* * * DON'T EDIT BELOW THIS LINE * * */
     (function() {
       var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
       dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
       (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
       $('#disqus_thread').css('display','none');
     })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    <div class="ds-thread"></div>
    <script type="text/javascript">
     var duoshuoQuery = {short_name:'lujun9972'};
     (function() {
       var ds = document.createElement('script');
       ds.type = 'text/javascript';ds.async = true;
       ds.src = 'http://static.duoshuo.com/embed.js';
       ds.charset = 'UTF-8';
       (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
       $('.ds-thread').css('display','block');
     })();
    </script>
  </section>
  <script src="http://lujun9972.github.io/media/js/main.js"></script>
  <div class="footer">
    <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.x(<a href="http://orgmode.org">Org mode</a> 8.x)</p>
    <p>
      Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:Administrator@PC-201510071640">DarkSun</a>
      &nbsp;&nbsp;-&nbsp;&nbsp;
      Powered by <a href="https://github.com/emacs-china/ego" target="_blank">EGO</a><br/>
      <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
      <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
    </p>
  </div>
    </div>

  </div></body>
</html>
